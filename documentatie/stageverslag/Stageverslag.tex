\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{todonotes}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{rotating}
\usepackage{blindtext}

\usepackage[a4paper, total={6in, 8in}]{geometry}

\begin{document}
	\sffamily
	\begin{titlepage}
		\begin{center}
			\includegraphics[width=8cm]{Sens2SeaLogo.png}

			\vspace*{4cm}
			\Huge
			\textbf{Aansturing freesbank} \\
			\LARGE
			\vspace{0.5cm}
        Stage verslag \\ 
				Sens2Sea
			
			\vspace{1.5cm}
					
			\huge
			\textbf{Olaf Goudriaan}
			\vspace{1.5cm}	
			\vfill
			\Large
			\begin{flushright}
				Geert Mosterdijk \\
				TINSTG05 \\
				Wessel Oele, Renee van Dorn \\
				1071349	\\
				2025 - 2026
			\end{flushright}
			
		\end{center}

	\end{titlepage}
	\newpage
 	\renewcommand{\familydefault}{\sfdefault}
	\tableofcontents
	\newpage
	\normalsize
	\paragraph{Voorwoord}
	Ik dank hierbij iedereen die heeft geholpen met de stage en de leuke stageopdracht. Ik ben veel gegroeid in dit half jaar in hard en soft skills. Ik heb nieuwe ervaringen opgedaan, ben op plekken geweest waar je normaal niet kan komen, heb het gezellig gehad met de collega's. Ook heb ik veel nieuwe dingen geleerd zoals Freecad en regeltechniek. Hiernaast ben ik door de toepassingen van de wiskundige formules beter geworden in wiskunde en natuurkunde. Ook zijn de onderdelen die kapot aan kwamen een les om daar goed mee om te gaan. En ik denk een mooi prototype neergezet te hebben.

	\todo{naam file aanpassen}
	\section{Context}
		\subsection{Het bedrijf}
			De stage heeft plaatsgevonden bij het bedrijf Sens2Sea. Dit is een klein bedrijf dat gevestigd is in Rotterdam op een kavel in het Innovation Dock op het RDM terrein. Sens2Sea ontwikkelt radar technologieën voor sectoren zoals de scheepsvaart en andere maritieme sectoren. Het bedrijf wordt geleid door Geert Mosterdijk. Het bedrijf heeft maar een paar medewerkers. Deze zijn gespecialiseerd in diverse vakgebieden zoals elektronica en software. Verder lopen er bij Sens2Sea een aantal studenten van verschillende opleidingen stage. Het bedrijf werkt voor projecten samen met andere bedrijven. Deze bedrijven zijn tevens de stakeholders voor de projecten. Voor dit bedrijf geldt het volgende:
			\begin{enumerate}
				\item Sens2Sea. De opdracht is voor Sens2Sea, dit bedrijf bepaalt welke beslissingen gemaakt worden. Dit bedrijf heeft mensen in dienst die expertise bieden op gebied van elektronica en software. (Hoge invloed en Hoog belang)
				\item PKMarine. Dit bedrijf werkt samen met Sens2Sea en bied expertise in regeltechniek. (Hoge invloed, laag belang)
				\item CoE HRTech. Dit bedrijf financiert het project. (Lage invloed en hoog belang)
			\end{enumerate}

		\subsection{Opdracht}
			\noindent Sens2Sea is bezig met radar technologie. Radar is een technologie die radiogolven gebruikt om, ten opzichte van de positie van de radar, de afstand, snelheid en richting van objecten te bepalen. Radar kan gebruikt worden in goed en slecht weer. Hierdoor is het uitstekend geschikt om objecten te detecteren in sectoren zoals de scheepsvaart. Ook kan de radar technologie van Sens2Sea gebruikt worden om de zeebodem in kaart te brengen en om olievlekken te detecteren. \\
			{\color{white}-}\\
			\noindent Sens2Sea is sinds kort bezig met FMCW (Frequency Modulated Continuous Wave) radar technologie. Hiervoor wil Sens2Sea paraboolantennes gebruiken. Deze antennes zorgen ervoor dat de radiogolven zodanig worden gebundeld de ontvangen waardoor de radar reflecties worden versterkt. Dit zorgt ervoor dat het beeld een betere resolutie heeft. Deze antennes zijn niet te verkrijgen in alle maten omdat een antenne gemaakt wordt met een mal. Een mal is duur om te maken waardoor een antenne op maat een stuk duurder wordt dan een standaardmaat. Om deze reden wil Sens2Sea graag zelf dergelijke antennes kunnen maken. Er zijn hiervoor al testen geweest met antennes die in stukken geprint zijn met een 3D printer. Dit heeft redelijk goed uitgepakt, hoewel al snel bleek dat tijdens het hechten van de onderdelen, er een fout in de vorm ontstaan waardoor de antenne minder werkt. Om deze reden wil Sens2Sea de antennes in één keer kunnen produceren met een 3D printer CNC machine combinatie. Deze machine moet in staat zijn antennes tot 4m x 1m x 1m kunnen produceren. \\
			{\color{white}-}\\
			\noindent Er zijn verschillende opensource oplossingen zoals zoals GRBL en Marlin om CNC-machines en 3D printers aan te sturen. Een 3D printer bouwt een model op door laagjes toe te voegen en een CNC machine die haalt laagjes weg om het model te krijgen. Deze oplossingen gebruiken de stappen van de stappenmotor om te bepalen waar de freeskop zich bevind. Doordat er geen sensoren in het systeem zijn kan de microcontroller niet weten of de stappen echt gezet zijn en wordt de locatie minder nauwkeurig. Er zijn nog meer opensource oplossingen, maar geen van allen voldoen aan wat Sens2Sea wenst. Met name is de nauwkeurigheid een probleem. Het bedrijf denkt dat indien de aansturing en de locatie bepaling worden gescheiden de machine nauwkeuriger kan werken. Ook denkt Sens2Sea dat het systeem modulair moet zijn opdat componenten als sensoren en actuatoren eenvoudig kunnen worden vervangen. Tenslotte is er de wens dat de freeskop van de machine op termijn over vijf assen moet kunnen bewegen. Deze assen zijn de bewegings assen X, Y, Z en daarnaast de rotaties over de X en Y as.\\
			{\color{white}-}\\
			\noindent De scope van het project omvat het scheiden van de aandrijving en positiebepaling van de freeskop. Daarnaast is er sprake van aanpassen of herschrijven van GRBL om deze te laten werken met de positie sensoren. Ook de hardware aansturen/aansluiten hoort bij de scope. Het aansturen of vervangen van de frees door de microcontroller, 3D print functie en het bewegen van de freeskop over de rotatie assen X en Y vallen buiten de scope van het project.

	\newpage
	\section{Analyse}
		\subsection{Huidige situatie}
			\begin{center}
				\includegraphics[width=11cm]{Freesbank-oude-componenten}\\
				Figuur 1: Freesbank huidige situatie
			\end{center}
			De huidige situatie bestaat uit een aantal componenten die te zien zijn in figuur 1. Er zijn al verschillende componenten aanwezig zoals de drivers van de motoren, motoren, freesbank met frees en een microcontroller. Hierin is de microcontroller een Arduino Uno met de opensource software GRBL.\\~\\

			\noindent De freesbank is gemaakt van hout en heeft drie assen en een handfrees. De buitenmaten zijn 300cm in de lengte(X), 152cm in de breedte(Y) en 60cm hoog(Z). Bij de maat van de hoogte is de lengte van de poten niet meegerekend. De werkruimte dat de freesmachine kan bereiken is 251 cm in de lengte, 127.5 cm in de breedte en 8 cm in de hoogte. De freesbank kan in drie richtingen bewegen. De X-as is de lengterichting van de machine. Aan beide zijden bevinden zich rails. Over deze rails beweegt de carriage, het montageonderdeel dat over de X-as loopt waaraan de rest van de bewegingen zitten. Op de carriage is een tweede rails gemonteerd, waarover de montage van de Z-as kan bewegen. Deze beweging vindt zich plaats in de Y-richting. De Z-richting wordt bewogen met een schroef dat de frees beweegt over de Z-as. De X- en Y-as worden bewogen met tandriemen. De volledige constructie is te zien in Appendix C. \\~\\

			\noindent Aan de Z-as is een handfrees dat op netstroom werkt gemonteerd. Wanneer er gefreest wordt komt er materiaal los dat blijft liggen op de freesbank. Op de freesbank werken externe effecten zoals wrijving op de rails en uitrekking van de tandriemen. \\~\\

			\noindent De motoren die gebruikt worden voor de beweging van de assen zijn NEMA 17 motoren. Deze werken op 12-36V en mogen maximaal 2A hebben. De motoren zitten vast aan het frame met bevestigingspunten. De lengte-as heeft motoren aan beide kanten van de freesbank. De hoogte en breedte assen worden aangedreven door één motor. De datasheet van deze motor is te vinden in '7.1 Datasheets'. \\~\\

			\noindent De drivers die gebruikt worden voor de motoren zijn DRV8824 drivers. Deze drivers werken op 8.2-45V en mogen maximaal 2.5A hebben op 24V. Deze drivers maken gebruik van een STEP en DIR pin. Door de DIR pin hoog en laag te maken veranderd de polariteit over de aangesloten motor. Door de STEP pin hoog te maken zet de motor een stap. Deze drivers hebben ook de mogelijkheid om te microstappen. Microstappen maakt gebruik van sinusvormige stromen om meer nauwkeurigheid en hogere resolutie te krijgen. De drivers zitten op een CNC shield dat 5V en 40mA nodig heeft. Dit krijgt deze de microcontroller. De drivers krijgen voeding van een lab voeding. De datasheet van deze drivers en CNC shield zijn vinden in '7.1 Datasheets'.\\~\\

			\noindent De microcontroller is een een Arduino Uno met de opensource software GRBL. Dit is het onderdeel dat input van de gebruiker krijgt en informatie over het systeem terugstuurt naar de gebruiker. De input dat de gebruiker kan geven zijn systeem commando's waarmee de status van de machine wordt opgevraagd. Hiernaast kan de gebruiker G-Code sturen naar de microcontroller. De microcontroller wordt gevoed door een laptop met 5V en 200mA.\\~\\

			\noindent G-Code is een commando dat gebruikt wordt door freesmachines en 3D printers. Deze codes worden aangegeven met de letter G. Hiernaast worden ook M-Codes gebruikt om deze machines uit te voeren. Deze codes zijn hulpcodes om extra instructies te geven maar deze codes zijn even belangrijk als de G-Codes. In dit verslag zullen beide soorten G-Code genoemd worden.\\~\\

			\noindent Er zijn drie voedingen in de huidige situtatie. De voeding voor de motor drivers is 24V 2A met een lab voeding. Het regelsysteem wordt gevoed door een laptop met 5V en 200mA. Hiernaast is er nog een voeding. Deze voeding voed de handfrees met netstroom. 

		\subsection{Sensor}
			\noindent Uit een interview met de opdrachtgever is gebleken dat de opdrachtgever enocders wilt gebruiken. Dit mogen geen stappenmotoren zijn met encoders bevestigd omdat het bedrijf dan afhankelijk is van de fabrikant van de encoders. De opdrachtgever wilt indien nodig de nauwkeurigheid van de machine verhogen met andere soorten sensoren. \\~\\

			\noindent Voor dit prototype is het belangrijk dat de locatie bepaling gescheiden wordt van de aansturing van de motoren. Verder mag de prijs van de encoder niet boven de 60 euro per encoder uitkomen. Er is geen eis voor de nauwkeurigheid van de encoder omdat dit niet het belangrijkste is voor dit prototype.\\~\\

			\noindent Er zijn verschillende soorten encoders waarnaar onderzoek gedaan is. De nauwkeurigheid van een encoder wordt gemeten in Pulses Per Rotation(PPR). Dit betekent dat hoe hoger de PPR is, hoe nauwkeuriger de encoder is. Na het onderzoek zijn de opties voorgelegd aan de opdrachtgever en is er gekozen om een optische incrementele encoder(me38s6-c-(600)b5g2) te gebruiken. Dit omdat deze encoder relatief goedkoop met een goede nauwkeurigheid ten opzichte van andere encoders. De datasheet van deze sensor is te vinden in '7.1 Datasheets'. Het onderzoek is te vinden in Appendix A. 

		\subsection{Microcontroller}
			het huidige systeem maakte gebruik van een Arduino Uno. Deze microcontroller heeft niet genoeg interrupt pinnen voor de encoders. Interrupt pinnen zijn speciale pinnen op een microcontroller. Deze pinnen onderbreken de code waardoor een ander stuk code uitgevoerd kan worden. Hierna gaat de microcontroller weer verder met waar deze meebezig was. De huidige microcontroller heeft niet genoeg van deze pinnen. Verder heeft deze microcontroller niet genoeg pinnen voor de uitbreidingen die in de toekomst toegevoegd zullen worden. In overleg met de opdrachtgever besloten om een Arduino Mega te gebruiken. Deze microcontroller heeft meer rekenkracht dan de Arduino Uno en heeft veel meer pinnen. Ook maakt het bedrijf al gebruik van de Arduino omgeving waardoor er al kennis over is.

		\subsection{Requirements}
			Uit de analyse en interviews met de opdrachtgever zijn er eisen opgesteld. 
			
			\begin{center}
				\scalebox{0.8}{
				\begin{tabular}{|c|c|c|}
					\hline
					De freeskop moet in de X-richting & Als opdrachtgever wil ik dat de & Funct.\\
					kunnen bewegen. & freeskop in de X-richting kan bewegen. & \\
					\hline
					De freeskop moet in de Y-richting & Als opdrachtgever wil ik dat de & Funct.\\
					kunnen bewegen. & freeskop in de Y-richting kan bewegen. & \\
					\hline
					De freeskop moet in de Z-richting & Als opdrachtgever wil ik dat de & Funct.\\
					kunnen bewegen. & freeskop in de Z-richting kan bewegen. & \\
					\hline
					De positie van de freeskop op de X-as  & Als opdrachtgever wil dat de positie van de freeskop  & Funct.\\
					moet bepaald worden met een encoder. & op de X-as bepaald wordt met een encoder. & \\
					\hline
					De positie van de freeskop op de Y-as  & Als opdrachtgever wil dat de positie van de freeskop  & Funct.\\
					moet bepaald worden met een encoder. & op de Y-as bepaald wordt met een encoder. & \\
					\hline
					De positie van de freeskop op de Z-as  & Als opdrachtgever wil dat de positie van de freeskop  & Funct.\\
					moet bepaald worden met een encoder. & op de Z-as bepaald wordt met een encoder. & \\
					\hline
					De freesbank moet G-Code kunnen ontvangen  & Als opdrachtgever wil ik dat de freesbank  & Funct.\\
					en uitvoeren. & G-Code commando's kan ontvangen en uitvoeren & \\
					\hline
					De software moet modulair opgebouwd zijn. & ALs opdrachtgever wil ik dat de software van & Niet funct. \\
					& de freesbank modulair opgebouwd is, omdat er gemakkelijk & \\
					& onderdelen aan toegevoegd moeten kunnen worden. & \\
					\hline
				\end{tabular}}
			\end{center}

	\section{Ontwerpen}
		Uit de wensen en eisen van de opdrachtgever ontstaat er een nieuw diagram.
		\begin{center}
			\includegraphics[width=11cm]{Freesbank-nieuwe-componenten.png}\\
			Figuur 2: Freesbank Nieuw ontwerp
		\end{center}
		In figuur 2 is het nieuwe ontwerp te zien waaraan een encoder is toegevoegd. Iedere as heeft zijn eigen encoder waardoor de bewegingen per as gemeten kan worden. De encoders moeten bevestigd worden op een getande riem dat op het frame is geplakt. Doordat deze riem op het frame geplakt is, kan deze niet uitrekken waardoor de nauwkeurigheid gewaarborgd blijft. De encoder gebruikt 5V en 40mA en krijgt deze voeding van de microcontroller. De encoders sturen als deze gedraait worden pulsen naar de microcontroller die deze verwerkt. Verder is de microcontroller vervangen door een Arduino Mega. Deze microcontroller verstuurd de step en richting signalen naar de motor drivers. 

		\subsection{Software ontwerpen}
			Voor de software zijn verschillende ontwerpen gemaakt. Dit zijn de state machine en flowchart.
			\begin{center}
				\includegraphics[width=10cm]{statemachine.png}\\
				Figuur 3: Software state machine.
			\end{center}

			\noindent In software diagram A is de state machine te zien. Hierin is te zien in welke states het systeem zich kan bevinden. Het systeem start bij 'IDLE'. Hierna kan het systeem opdrachten krijgen waardoor de state 'RUNNING' wordt. De opdrachten kunnen klaar zijn of worden geannuleerd. Hierna wordt de state veranderd naar 'IDLE'. Er kunnen fouten optreden, Als dit gebeurt zijn er 2 states. Indien het systeem een fout heeft dat deze zelf kan verhelpen veranderd de state naar 'Out of service'. Als de fouten niet te verhelpen zijn moet er een restart komen door een mens en zal de state 'END PROGRAM RESTART REQUIRED' worden. Deze state gaat niet weg zonder dat er een restart is geweest.

			\begin{center}
				\includegraphics[width=8cm]{Flowchart-full.png}\\
				Figuur 3: Software Flowchart.
			\end{center}
			\noindent In figuur 3 is een flowchart te zien dat verdeeld is in meerdere kleuren. Oranje en geel zijn interrupts voor de input van de gebruiker. Rood is de interrupt van de sensoren en paars de interrupt die de motoren aanstuurt. Het blauwe gedeelte is de main loop die input, errors en het maken van opdrachten afhandelt. Als er een input van de gebruiker komt, wordt die gelezen. Als het een systeem opdracht is zoals de status opvragen zal die meteen worden afgehandeld door 'execute system command'. Anders wordt de G-Code gelezen en in de queue gezet. Als het G-Code commando meteen afgehandeld moet worden, zal dat gedaan worden.

		\subsection{Elektrisch schema}
			Er zijn twee elektrisch schema's gemaakt die te vinden zijn in Appendix B. Het eerste schema is gemaakt voor de aansturing op één as en bevat een Arduino Uno, encoder, DRV8824 motor driver, 100uf condensator en een NEMA17 stappen motor. Het tweede elektrisch schema is voor de volledige beweging van drie assen en bevat een Arduino Mega, 3 encoders, 3 DRV8824 motor drivers, 3 100uf condensatoren en 3 NEMA17 stappen motoren.			

	\section{Realisatie}
		\subsection{Mechanica}
			\begin{center}
				\includegraphics[width=5cm]{beugeliteratie-1.png}\\
				Figuur 4: Mechanica Iteratie 1
			\end{center}
			Omdat de encoder over een randriem moet lopen die vast zit op de Z-as is een beugel nodig. De opstelling hiervoor is te zien in Appendix C, figuur 11 en figuur 12. De opdrachtgever wil dat er een ontwerp komt dat met een veer ervoor zorgt dat de encoder altijd op de tandriem blijft lopen. Hiernaast is het belangrijk dat het model gemaakt wordt in freecad. Voor deze beugel zijn meerdere iteraties gemaakt waarvan de eerste iteratie instabiel was. Hierdoor was er veel beweging wanneer de freesbank bewoog. De oorzaak van dit probleem lag bij dat de staven tussen de twee bewegende delen heel dun waren waardoor er veel speling op zat. Hiernaast braken de staven af wanneer een veer toegevoegd werd, omdat deze te dun waren. Ook had dit model een probleem dat deze niet goed paste omdat er geen rekening gehouden was met een metalen staaf waarlangs de Z-as beweegt.

			\begin{center}
				\includegraphics[width=4cm]{beugeliteratie-2.png}\\
				Figuur 4: Mechanica Iteratie 2
			\end{center}
			In de tweede iteratie zijn deze problemen opgelost. Deze iteratie maakt gebruik van een driehoek vormige gleuf waarin het bewegende deel kan bewegen. Ook is er ruimte voor een spijker met de veer om het bewegende deel omlaag te duwen. Hierdoor zit er geen speling tussen de bewegende onderdelen waardoor de encoder niet heen en weer kan bewegen bij trillingen. Dit ontwerp heeft een probleem dat de Z-as niet meer volledig naar beneden kan doordat het ontwerp hoog is en recht onder het bewegende deel van de Z as zit zit.

			\begin{center}
				\includegraphics[width=5cm]{beugeliteratie-3.png}\\
				Figuur 4: Mechanica Iteratie 3
			\end{center}
			Voor de derde iteratie is er een plaat gemaakt dat over de gehele bovenkant van de Z-as zit. Deze plaat steekt uit waardoor iteratie 2 hierop gemonteerd kan worden. Met dit ontwerp kan de Z-as volledig naar boven en beneden bewegen. Dit ontwerp zorgt ervoor dat de Y-as ongeveer 4 cm kleiner wordt, maar dit is volgens de opdrachtgever geen groot probleem voor het prototype.
			

		\subsection{Software}
			De software is opgebouwd uit de verschillende modules: Datacommunicatie, stepper, encoder en system. Ook is er een bestand main waar het programma begint en een macros.h file waar alle macros zich bevinden. De software is geschreven in C++ maar maakt geen gebruik van classes. De software maakt geen gebruik van de Arduino.h library. Hierdoor zijn alle Arduino functies niet beschikbaar en worden pinnen rechtstreeks gezet met door de registers te beïnvloeden. Ook interrupts worden op deze manier toegevoegd. Interrupts zijn seinen die de processor vertellen dat die moet stoppen met waar die nu mee bezig is en de code die bij die interrupt hoort moet uitvoeren.

			\paragraph{Main}
				Deze module definieert het begin van het programma. Hier bevindt zich de main loop waaruit alle andere functies van andere modules worden aangeroepen. Deze module initialiseert alle andere modules indien nodig en leegt de seriële buffer voor de zekerheid.

			\paragraph{Macro's}
				Deze header file heeft alle macro's die nodig zijn voor het bestand. Macro's zijn woorden die door de compiler veranderd worden in de definitie van de macro. Dus als er een macro \small \textbf{TIJD\_MS 3} \normalsize is, zal de compiler alle instanties van \small \textbf{TIJD\_MS 3} \normalsize veranderen in 3. Een belangrijk onderdeel van dit bestand is de custom datatypes. Omdat een int op een Arduino geen 32 bit maar 16 bit is, kloppen de standaard uint32\_t datatypes niet. Hiervoor zijn deze opnieuw gedefinieerd als:\small \textbf{uchar, uint8, int8, uint16, int16, uint32, int32}\normalsize. Floats en doubles zijn dezelfde grootte op een Arduino dus wordt er verder alleen float gebruikt. Hier zijn ook alle pin en port definities te vinden.

			\paragraph{Datacommunicatie}
				Deze module zorgt voor de seriële verbinding met de gebruiker. De standaard Arduino library voldoet niet aan de benodigdheden voor een machine dat snel en nauwkeurig moet werken. Dit komt doordat de functies van deze library blokkerend zijn. Dit betekent dat wanneer de buffer op de Arduino vol zit omdat het niet snel genoeg verstuurd wordt of ontvangen wordt, de Arduino wacht met alles wat gedaan moet worden inclusief bewegingen totdat er weer characters op de buffer kunnen. De implementatie van dit project werkt op dezelfde manier als de standaard library, maar deze gooit de characters weg als de buffer vol zit, waardoor de bewegingen nauwkeurig blijven. Deze module bevat ook verschillende high level implementaties om de data te sturen. Er kunnen door de \textbf{print()} functie intergers, chars, floats, strings, en nog meer verschillende datatypes geprint worden. 

			\paragraph{Stepper}
				Deze module zorgt voor alle functies van de steppers. Eerst wordt een segment(block) klaar gemaakt. Dit block heeft een aantal eigenschappen, Hieronder vallen alle parameters meegegeven met de G-Code commando's. Hiervan worden een paar extra parameters berekend die nodig zijn per stap. Het stappen wordt gedaan door een interrupt die iedere aantal milliseconde uitgevoerd wordt. Deze snelheid is gedefinieerd in macros.h. Voor ieder segment wordt er een wiskundige formule opgesteld voor het pad dat de motoren moeten volgen. Iedere as heeft zijn eigen formule. Deze formules zorgen ervoor dat als de machine naar (X=10, Y=5, Z=2) moet, alle assen op hetzelfde moment aankomen. Er zijn twee verschillende modellen: Rechte beweging, Cirkelbeweging. De commando's zijn te vinden in de handleiding. \\ \\
	
				\noindent De rechte beweging is per as met een lineaire formule. Deze formule gaat op de X-as (T) van t=0 naar t=eind. De eindtijd wordt bepaald door de totale afstand te delen door de afstand per puls van een stappen motor. De Y-as(P) gaat van de beginpositie van die as tot de eind positie van die as in de tijd van t=0 naar t=eind. Omdat de t=eind hetzelfde is bij iedere as zorgt deze constructie ervoor dat de assen op hetzelfde moment aankomen. Iedere tijdstap wordt er gekeken of de locatie achter ligt of voor ligt op de formule. Als de locatie achter ligt zal de motor een stap zetten.
				\begin{center}
					\includegraphics[width=10cm]{model-rechtebeweging.png}\\
					Figuur 5: Software lineaire beweging.
				\end{center}
				De cirkelbeweging wordt gedaan met sinus en cosinus functies. Deze functies hebben een 4ste cirkel verschil met elkaar waardoor als deze gecombineerd worden er een cirkel beweging ontstaat. Ook deze functie gaat van t=0 naar t=eind. Maar deze word verschoven met de begin hoek. Als de cirkel tegen de klok in gaat wordt de sinus en cosinus vermenigvuldigd met -1. Hierdoor lopen de golven de andere kant op waardoor de assen tegen de klok in gaan. De cirkel kan maar gebruik maken van twee assen, dus zijn de commando's G17 tot G19 om te kiezen op welk vlak de machine moet werken. De standaard is op het XY vlak(G19).
				\begin{center}
					\includegraphics[width=10cm]{model-cirkelbeweging.png}\\
					Figuur 6: Software cirkelbeweging.
				\end{center}

			\paragraph{Encoder}
				Deze module zet de pulsen van de encoders om in een locatie. Deze module zet interrupts aan op alle pinnen van de machine. Als er een interrupt af gaat worden de beide pinnen uitgelezen. Door beide pinnen te gebruiken kan er onderscheid gemaakt worden tussen voor- en achteruit bewegen. Hieronder is de functie om de encoder uit te lezen te zien. Deze code maakt slim gebruik van bitwise operaties om het verschil te vinden. Dit stukje code wordt heel vaak uitgevoerd waardoor het belangrijk is dat dit heel snel is. De encoders maken gebruikt van de interrupt pinnen van de Arduino omdat deze de 2e hoogste prioriteit hebben op de Arduino. Deze pinnen staan ingesteld op 'any change' om de 'rising en falling edge' te detecteren.
				\begin{center}
					\includegraphics[width=13cm]{encodercode.png}\\
					Figuur 7: Software encoder interrupt.
				\end{center}

			\paragraph{System}
				Deze module gebruikt de andere modules om alle opdrachten uit te lezen uit de buffers, om te zetten naar bruikbare info en in de buffer voor de stappen motoren zetten. Deze module zet de G-Code om naar een block en zet in de buffer. Hiernaast voert deze module ook alle systeem commando's uit zoals $\$?$ om de huidige status uit te lezen. 


		\subsection{Test Rapport}
			Na de testen die beschreven staan in Appendix D is te zien dat de freesbank in alle richtingen bewogen kan worden, G-Code kan uitvoeren, modulair is en de locatie kan bepalen op de Y-as.
			\begin{center}
				\begin{tabular}{|c|c|c|}
					\hline
					Soort & Requirement & Uitslag \\
					\hline
					Funct & De freesbank moet G-Code kunnen ontvangen en uitvoeren. & Behaald. \\
					\hline
					Funct & De freeskop moet in de X-richting kunnen bewegen. & Behaald \\
					\hline
					Funct & De freeskop moet in de Y-richting kunnen bewegen. & Behaald \\
					\hline
					Funct & De freeskop moet in de Z-richting kunnen bewegen. & Behaald \\
					\hline
					Funct & De positie van de freeskop op de X-as  & Niet behaald \\
					&moet bepaald worden met een encoder. & \\
					\hline
					Funct & De positie van de freeskop op de Y-as & Behaald \\
					&moet bepaald worden met een encoder. & \\
					\hline
					Funct & De positie van de freeskop op de Z-as & Niet behaald \\
					&moet bepaald worden met een encoder. & \\
					\hline
					Niet. Funct & De software moet modulair opgebouwd zijn. & behaald \\
					\hline
				\end{tabular}
			\end{center}

	\section{Conclusie}
		Aan de hand van alle test reslultaten is te concluderen dat de freesbank bijna naar behoren werkt. Alleen om de encoders de X- en Z-as te laten meten zijn er nog mechanische onderdelen nodig. Als deze encoders mechanisch zijn gemonteerd is de code gemakkelijk aan te passen om de bewegingen van de enocders te volgen.

	\section{Aanbevelingen}
			Tijdens dit project zijn meerdere onderdelen aan bod gekomen waar geen tijd voor was of buiten de scope lag. 

			\noindent Voor de X en Z assen moet er naar een manier gekeken worden om de encoders aan de assen te zetten. \\~\\

			\noindent In dit project is de handfrees gebruikt die al op de machine zat. Deze moet handmatig aangezet worden waardoor dit niet praktisch is. Dus zou er een frees moeten komen die aangestuurd kan worden door het regelsysteem. Ook maakt de frees materiaal los dat afgezogen moet worden. Hier moet ook over nagedacht worden.\\~\\

			\noindent De bekabeling van de freesbank is niet netjes. Voor het nieuwe ontwerp moet er voor gezorgd worden dat de kabels niet vast kunnen zitten in andere onderdelen van de machine. Hiernaast moet ervoor gezorgd worden dat de bekabeling niet hangt om kabelbreuken tegen te gaan.\\~\\

			\noindent De drivers van het systeem zitten in dit ontwerp op een CNC-shield. De pinconfiguraties van de code is anders dan de configuratie van het CNC-shield. Hierdoor moeten losse kabels gebruikt worden en de bevestigingspunten voor deze kabels zitten onder- en bovenop de shield. Om deze reden en dat de freesbank in de toekomst 5 assen moet krijgt zou een PCB maken te adviseren zijn.\\~\\

			\noindent Om de encoder uit te lezen wordt op dit moment interrupt pinnen gebruikt op de Arduino. Er zijn ook modules die de encoders pulsen opvangen en hiermee de locatie bepalen. Deze modules zouden alleen uitgelezen moeten worden door de microcontroller om de huidige locatie te krijgen. Of dit werkt moet onderzoek naar gedaan worden.\\~\\

			\noindent Het regelsysteem heeft een gelimiteerd aantal plekken in de buffer voor G-Code opdrachten. Hierdoor raakt de buffer van de seriële lijn vol waardoor andere belangrijke opdrachten niet binnen komen. Een SD kaart toevoegen aan het systeem waar de step files op staan zou dit verhelpen. Een andere oplossing is om een de bevestiging van het regelsysteem uit te lezen met de hoeveelheid plekken die aanwezig zijn om ervoor te zorgen dat alle informatie op het juiste moment binnen komt.\\~\\

			\noindent Het systeem moet gekalibreerd worden als deze gebruikt wordt. Dit kan gedaan worden door de freeskop van (X-, Y- en Z-) hoek naar de (X+, Y+ en Z+) hoek te bewegen en de encoderstappen tellen. Het aantal stappen per as kan door de lengte van de as gedeeld worden om de nauwkeurigheid te krijgen. \\~\\

			\noindent Het systeem maakt gebruikt van stappenmotoren. Deze motoren kunnen normale stappen zetten, maar ook microstappen. In het systeem worden normale stappen gebruikt. Maar microstappen zijn fijner en maken minder trillingen waardoor de nauwkeurigheid van de machine beter wordt.\\~\\

\newpage
	\section{Bronnen}
		\begin{enumerate}
			\item Wikipedia contributors, “Radar,” Wikipedia, The Free Encyclopedia (Dutch version). [Online]. Available: \url{https://nl.wikipedia.org/wiki/Radar}. Accessed: Jan. 6, 2026.
			\item Wikipedia contributors, “Radar,” Wikipedia, The Free Encyclopedia. [Online]. Available: \url{https://en.wikipedia.org/wiki/Radar}. Accessed: Jan. 6, 2026.
			\item Wikipedia contributors, “Incremental encoder,” Wikipedia, The Free Encyclopedia. [Online]. Available: \url{https://en.wikipedia.org/wiki/Incremental_encoder}. Accessed: Jan. 6, 2026.
			\item Wikipedia contributors, “Rotary encoder,” Wikipedia, The Free Encyclopedia. [Online]. Available: \url{https://en.wikipedia.org/wiki/Rotary_encoder}. Accessed: Jan. 6, 2026.
			\item Laumans Techniek, “Encoders voor industriële automatisering,” Laumans Techniek. [Online]. Available: \\\url{https://www.laumanstechniek.nl/blog/kennisbank-3/encoders-voor-industriele-automatisering-20}. Accessed: Jan. 6, 2026.
			\item Linear Motion Tips, “Microstepping Basics,” Linear Motion Tips. [Online]. Available: \url{https://www.linearmotiontips.com/microstepping-basics/}. Accessed: Jan. 6, 2026.
			\item Dynapar, “Magnetic Encoders,” Dynapar Knowledge Center. [Online]. Available: \url{https://www.dynapar.com/knowledge/encoder-basics/encoder-technology/magnetic-encoders}. Accessed: Jan. 8, 2026.
			\item Wikipedia contributors, “Gray code,” Wikipedia, The Free Encyclopedia. [Online]. Available: \url{https://en.wikipedia.org/wiki/Gray_code}. Accessed: Jan. 8, 2026. 
			\item Wikipedia contributors, “G-Code,” Wikipedia, The Free Encyclopedia. [Online]. Available: \url{https://nl.wikipedia.org/wiki/G-code}. Accessed: Jan. 30, 2026. 
			\item FreeCAD, FreeCAD: Your own 3D parametric modeler, FreeCAD Project. [Online]. Available: \url{https://www.freecad.org/}. Accessed: Jan. 30, 2026. 
		\end{enumerate}

		\subsection{Datasheets}
			\begin{enumerate}
				\item Texas Instruments, “DRV8824 Stepper Motor Controller IC,” Datasheet. [Online]. Available: \url{https://www.ti.com/lit/ds/symlink/drv8824.pdf}. Accessed: Jan. 6, 2026.
				\item PBC Linear, “Stepper Motor Support: NEMA 17 Data Sheet,” PBC Linear. [Online]. Available: \url{https://media.pbclinear.com/pdfs/pbc-linear-data-sheets/data-sheet-stepper-motor-support.pdf}. Accessed: Jan. 6, 2026.
				\item “Datasheet E38S6G5-600B-G24N,” engautomacaoing, Scribd, [Online]. Available: \url{https://www.scribd.com/document/756625816/Datasheet-E38S6G5-600B-G24N}. Accessed on: Jan. 27, 2026.
				\item Handson Technology, “3-Axis CNC/Stepper Motor Shield for Arduino User Manual,” Handson Technology, Online. Available: \url{https://www.handsontec.com/dataspecs/cnc-3axis-shield.pdf}. Accessed on: Jan. 29, 2026.
			\end{enumerate}

\todo{code in bijlage linken}
	\newpage
	\appendix
		\section{Encoder onderzoek}
			Voor de positie van de freeskop van een freesbank te bepalen zijn verschillende mogelijkheden. Uit een interview met de opdrachtgever is gekomen dat deze encoders wilt gebruiken. Een encoder is een sensor met een roterende as. Als deze as draait zet de encoder de beweging om in elektrische signalen. Hierdoor kunnen microcontrollers de positie, snelheid en richting bepalen. De encoders zijn onder te verdelen in verschillende soorten: Incrementeel of absoluut. Ook zijn er verschillende meet methodes: Magnetisch of optisch. Er zijn ook encoders die lineair zijn, maar daarvan heeft de opdrachtgever aangegeven dat die niet bruikbaar zijn. Bij de keuze moet ook rekening gehouden worden met dat de prijs van een sensor onder de 60 euro moet blijven. 

			\subsection{Meet methodes}
				Er zijn verschillende manieren om de beweging te meten. Hiervoor zijn optisch en magnetisch de meest gebruikte technologieën.

				\noindent\textbf{Magnetische} encoders maken gebruik van een magnetisch veld om de rotatie van de as te bepalen. Dit heeft het voordeel dat deze robuuster zijn. Hiernaast zijn deze ook beter bestand tegen vervuiling, trillingen en extreme omgevingsomstandigheden. Het nadeel is dat sterke magnetische velden metingen van andere sensoren kunnen beïnvloeden. Er zijn ook drie grote groepen magnetische encoders.\\
				\begin{enumerate}
					\item \textbf{Magnetic Gear Tooth Sensor or Pickup}, Deze encoder heeft een magnetische sensor en een ferromagnetische tandwiel. Dit betekend dat het tandwiel in staat is om een magnetisch veld te geleiden. Het voordeel hiervan is dat deze goedkoop zijn, alleen zijn deze gelimiteerd door het aantal tanden. Dit limiteert de resolutie naar 120 of 240 PPR.
					\item \textbf{Magneto-Resistive}, Deze encoder genereert een sinus golf door weerstand te meten op een wiel met afwisselende magnetische polen of een film met weerstanden. De afwisselende magnetische polen bieden een hogere nauwkeurigheid dan het film met weerstanden. Deze encoders zijn moeilijker om te integreren in een systeem.
					\item \textbf{Hall-Effect magnetic}, Deze encoder maakt gebruik van het Hall-Effect. De encoder bevat een laag van een halfgeleider materiaal dat verbonden is met een voeding. als een magnetische pool langs de hall-effect sensor komt, word er een hoge voltage gegenereerd. De frequentie en amplitude van de verstoring in het magnetisch veld kan worden gebruikt om de snelheid en verplaatsing te bepalen. 
				\end{enumerate}


				\noindent\textbf{Optische} encoders zijn encoders die gebruik maken van optische signalen om stappen te tellen. Dit doen deze encoders door een schijf met patronen dat vast zit aan de as. Door een lichtsensor worden deze patronen omgezet in elektrische pulsen. Deze sensoren bieden hoge resolutie en nauwkeurigheid. Hierdoor zijn deze encoders goed op plekken waar veel nauwkeurigheid verwacht wordt. Het nadeel van deze sensoren is dat deze gevoeliger zijn voor stof, vuil en trillingen.

			\subsection{Encoder soorten}
				\noindent\textbf{Incrementele} encoders genereren pulsen als de as beweegt. Op de schijf zijn er 1 of meerdere rijen met patronen. die rijen heten kanalen en als er twee of meer kanalen zijn, is het mogelijk om de richting bepalen. Deze patronen zijn 1/4 patroon van elkaar verschoven. Hierdoor krijg je bij een encoder met twee kanalen een patroon in de signalen. Dit betekend ook dat deze het zelfde aantal draden heeft als kanalen. Doordat de encoder een patroon volgt ten opzichte van een referentie punt, moet de microcontroller zelf de positie bijhouden. Hierdoor gaat de positiebepaling verloren als er een stroomonderbreking is. \\
				
				\noindent Het aantal patronen per kanaal bepaald de nauwkeurigheid. Indien een encoder meerdere kanalen heeft vergroot dat de nauwkeurigheid. Bij een encoder met twee kanalen gaat de nauwkeurig maal vier. Bijvoorbeeld bij 600 PPR (Pulses Per Rotation) op één kanaal, is de nauwkeurig op twee kanalen $600*4=2400$ PPR. \\
				
				\noindent Het patroon van de signalen is in graycode dat te zien is in figuur 8. Graycode is een ander soort binaire code dat bij elke ophoging en verlaging één bit veranderd. De signalen moet je opvangen met een microcontroller via polling of interrupts. Een interrupts vertelen de microcontroller dat er een verandering is in de pin waarop de interrupt staat. Hiernaast is polling het steeds kijken of de status veranderd is. Interrupts zijn hierin handiger omdat er dan geen data verloren kan gaan door een te langzame sample snelheid.
					\begin{center}
						\begin{tabular}{ c|c }
							A & B \\
							\hline
							0 & 0 \\
							\hline
							1 & 0 \\
							\hline
							1 & 1 \\
							\hline
							0 & 1      
						\end{tabular}
						Figuur 8: Encoder output table.
					\end{center}

				\noindent De signalen moeten worden opgevangen door een microcontroller. Dit kan via polling of interrupts. Interrupts stoppen het programma en voeren hun code uit, hierna kan het programma weer verder gaan. Polling is een manier van input lezen door iedere keer te kijken of de data veranderd is. Interrupts zijn hiervoor beter omdat er bij polling data verloren kan gaan door een te lage sample snelheid. De andere kant is dat een microcontroller maar een bepaald aantal interrupts per seconde kan verwerken.\\

				\noindent Absolute encoders zijn encoders die elke positie op de schijf een unieke code geven. Hierdoor weet de encoder exact waar die zich bevind in de rotatie. Hierdoor gaat de positie niet verloren als de spanning onderbroken is. Absolute encoders onthouden niet standaard het aantal rotaties die zijn gedaan. Hiervoor zijn multi-turn varianten. Absolute encoders moeten worden uitgelezen met een protocol zoals SPI. Op een Absolute encoder bepaald het aantal bits hoe nauwkeurig de encoder is. Een multi-turn absolute encoder heeft x aantal bits per rotatie en x aantal bits voor de aantal rotaties. \\
				
				\noindent Absolute encoders zijn duurder dan incrementele encoders. Van absolute zijn de multi-turn encoders duurder dan single-turn encoder.
				\begin{center}
					\begin{tabular}{|c|c|c|}
						\hline
						& absolute & Incrementeel\\
						\hline
						Kosten & Duur & goedkoper \\
						\hline
						uitlezen & protocol & pulsen tellen \\
						\hline
						positie onthouden zonder stroom & ja & nee \\
						\hline
					\end{tabular}
				\end{center}

				\noindent Om zeker te weten of een incrementele encoder kan werken door middel van interrupts, is er een testje gedaan. Door de interrupt pin te verbinden met een andere pin die steeds hoog en laag gemaakt wordt, is er getest hoeveel interrupts de microcontroller kan krijgen in een seconde. Deze test geeft een idee hoeveel de microcontroller kan hebben. Hierin wordt de tijd gemeten door de tijd van de seriële monitor.

				\begin{center}
					Op tijdstip 1: $09:36:47.772$ waren er $848785$ interrupts geweest. \\
					Op tijdstip 2: $09:36:53.204$ waren er $1484065$ interrupts geweest.\\ 

					Dit betekent dat er in $5.432$ seconde $635280$ interrupts zijn geweest. \\
					$5.432/635280 \approx 116951$ interrupts per seconde.
				\end{center}
				Een pulley van 16 tanden op een tandriem van 1mm tanden geeft 2mm op een tand. $2 * 16 = 32$mm per rotatie. Indien er $20000$ interrupts per as gebruikt kunnen worden door de sensoren kan de freesbank in theorie $20000 / 2400 * 32 \approx 266.6$mm/s bewegen. Dit is genoeg dus deze soorten encoders zijn een optie.

				{\color{white}-}\\Na de opties voorgelegd te hebben aan de opdrachtgever heeft de opdrachtgever gekozen voor een betaalbare optische incrementele encoder. Dit is uiteindelijk de 'me38s6-c-(600)b5g2' rotary encoder geworden. Deze encoder heeft 600 PPR per kanaal. Dus 2400 PPR in dual channel. 
		\newpage

		
		\section{elektrische schema's}
		\begin{center}
		\includegraphics[scale=0.70]{CNC-1as-elektrisch-schema.pdf}\\
			Figuur 9: Elektrisch schema één as.
		\end{center}
		\begin{sidewaysfigure}
			\begin{center}
			\includegraphics[scale=0.60]{CNC-3asen-elektrisch-schema.pdf}
			Figuur 10: Elektrisch schema drie assen.
			\end{center}
		\end{sidewaysfigure}
		\newpage



		\section{Plaatjes systeem}
			\begin{center}
				\includegraphics[width=12cm]{sideview.png}\\
				Figuur 11: Zijaanzicht freesbank.
				\includegraphics[width=12cm]{frontview.png}\\
				Figuur 12: Vooraanzicht freesbank.
				\includegraphics[scale=0.8]{beugel-overbrugging.png} \includegraphics[scale=0.8]{beugel-overbrugging-encoder.png}\\
				Figuur 13: Links de Y-as zonder encoder, Rechts de Y-as met encoder en mechanische onderdelen..		
			\end{center}

		\newpage

		\section{Testrapport}
			In dit rapport worden alle testen voor de eisen van het prototype weergegeven. Het prototype moet verschillende dingen kunnen. Deze zijn gedefineerd in de requirements en zijn de volgende:
			\begin{enumerate}
				\item De freesbank moet G-Code kunnen ontvangen en uitvoeren.
				\item De software moet modulair opgebouwd zijn.
				\item De freeskop moet in de X-richting kunnen bewegen.
				\item De freeskop moet in de Y-richting kunnen bewegen.
				\item De freeskop moet in de Z-richting kunnen bewegen.
				\item De positie van de freeskop op de X-as moet bepaald worden met een encoder.
				\item De positie van de freeskop op de Y-as moet bepaald worden met een encoder.
				\item De positie van de freeskop op de Z-as moet bepaald worden met een encoder.
			\end{enumerate}

			\subsection{G-Code ontvangen en uitvoeren}
				Voor deze requirement moet het prototype G-Code kunnen ontvangen en uitvoeren. Deze test is voldaan wanneer de machine G-Code commando's kan uitvoeren die de gebruiker stuurt via de seriële monitor.

				\paragraph{Deze} test kan alleen op de machine uitgevoerd worden. Hiervoor zijn de volgende dingen nodig:
				\begin{enumerate}
					\item Microcontroller met code dat G-Code kan ontvangen en uitvoeren.
				\end{enumerate}

				\begin{enumerate}
					\item Verbind de microcontroller met een laptop met seriële monitor.
					\item Start de seriële monitor en stuur het commando G1 X10.
					\item Wacht totdat de machine 'OK.' geeft terug stuurt.
					\item Herhaald dit voor alle andere commando's die beschikbaar zijn.
				\end{enumerate}

				\paragraph{Waarnemingen en conclusie}
					Na het sturen van ieder commando stuurt de machine 'OK.' terug. Dit geeft aan dat de test geslaagd is.

			\subsection{X-richting bewegen}
				Voor deze requirement moet het prototype in de X-richting kunnen bewegen. Deze test is voldaan wanneer de machine in de X-richting beweegt. Voor deze test moet de machine G-Code kunnen uitvoeren.

				\paragraph{Deze} test kan alleen op de machine uitgevoerd worden. Hiervoor zijn de volgende dingen nodig:
				\begin{enumerate}
					\item Microcontroller met code dat G-Code kan ontvangen en uitvoeren en assen kan laten bewegen.
					\item Stappenmotor met driver.
					\item Bedrading.
				\end{enumerate}

				\begin{enumerate}
					\item Bedraad alle componenten zoals aangegeven is in het elektrische schema.
					\item Verbind de microcontroller met een laptop met seriële monitor.
					\item Start de seriële monitor en stuur het commando G1 X10.
					\item Wacht totdat de machine 'OK.' geeft en de machine gaat bewegen
					\item Als de X-as is bewogen stuur dan het commando G1 X0 en wacht totdat de machine terug is bewogen naar het beginpunt.
				\end{enumerate}

				\paragraph{Waarnemingen en conclusie}
					Na het sturen van G1 X10 commando stuurt de machine 'OK.' terug en gaat de as bewegen. Na het sturen van G1 X0 beweegt de machine terug naar het beginpunt. Dit geeft aan dat de test geslaagd is.

			\subsection{Y-richting bewegen}
				Voor deze requirement moet het prototype in de Y-richting kunnen bewegen. Deze test is voldaan wanneer de machine in de Y-richting beweegt. Voor deze test moet de machine G-Code kunnen uitvoeren.

				\paragraph{Deze} test kan alleen op de machine uitgevoerd worden. Hiervoor zijn de volgende dingen nodig:
				\begin{enumerate}
					\item Microcontroller met code dat G-Code kan ontvangen en uitvoeren en assen kan laten bewegen.
					\item Stappenmotor met driver.
					\item Bedrading.
				\end{enumerate}

				\begin{enumerate}
					\item Bedraad alle componenten zoals aangegeven is in het elektrische schema.
					\item Verbind de microcontroller met een laptop met seriële monitor.
					\item Start de seriële monitor en stuur het commando G1 Y10.
					\item Wacht totdat de machine 'OK.' geeft en de machine gaat bewegen
					\item Als de Y-as is bewogen stuur dan het commando G1 Y0 en wacht totdat de machine terug is bewogen naar het beginpunt.
				\end{enumerate}

				\paragraph{Waarnemingen en conclusie}
					Na het sturen van G1 Y10 commando stuurt de machine 'OK.' terug en gaat de as bewegen. Na het sturen van G1 Y0 beweegt de machine terug naar het beginpunt. Dit geeft aan dat de test geslaagd is.
					
			\subsection{Z-richting bewegen}
				Voor deze requirement moet het prototype in de Z-richting kunnen bewegen. Deze test is voldaan wanneer de machine in de Z-richting beweegt. Voor deze test moet de machine G-Code kunnen uitvoeren.

				\paragraph{Deze} test kan alleen op de machine uitgevoerd worden. Hiervoor zijn de volgende dingen nodig:
				\begin{enumerate}
					\item Microcontroller met code dat G-Code kan ontvangen en uitvoeren en assen kan laten bewegen.
					\item Stappenmotor met driver.
					\item Bedrading.
				\end{enumerate}

				\begin{enumerate}
					\item Bedraad alle componenten zoals aangegeven is in het elektrische schema.
					\item Verbind de microcontroller met een laptop met seriële monitor.
					\item Start de seriële monitor en stuur het commando G1 Z10.
					\item Wacht totdat de machine 'OK.' geeft en de machine gaat bewegen
					\item Als de Z-as is bewogen stuur dan het commando G1 Z0 en wacht totdat de machine terug is bewogen naar het beginpunt.
				\end{enumerate}

				\paragraph{Waarnemingen en conclusie}
					Na het sturen van G1 Z10 commando stuurt de machine 'OK.' terug en gaat de as bewegen. Na het sturen van G1 Z0 beweegt de machine terug naar het beginpunt. Dit geeft aan dat de test geslaagd is.

			\subsection{X-richting meten}
				Voor deze requirement moet het prototype in de X-richting de afgelegde afstand kunnen bepalen doormiddel van een encoder. Deze test is voldaan wanneer de afstand dat de machine heeft afgelegd wordt bepaald door een encoder. Voor deze test moet de machine G-Code kunnen uitvoeren. 

				\paragraph{Deze} test kan alleen op de machine uitgevoerd worden. Hiervoor zijn de volgende dingen nodig:
				\begin{enumerate}
					\item Microcontroller met code dat G-Code kan ontvangen en uitvoeren en de afstand kan bepalen met een encoder.
					\item Encoder.
					\item Bedrading.
				\end{enumerate}

				\begin{enumerate}
					\item Bedraad de encoder met de microcontroller zoals aangegeven is in het elektrische schema.
					\item Verbind de microcontroller met een laptop met seriële monitor.
					\item Start de seriële monitor en stuur het commando $\$?$ om de huidige informatie op te halen.
					\item Beweeg de as met de hand en stuur het commando $\$?$ om de huidige informatie op te halen.
					\item Kijk of de het eerste getal veranderd is.
				\end{enumerate}

				\paragraph{Waarnemingen en conclusie}
					Er is geen encoder te bevestigen op deze as. Deze test is dus niet voltooid. 
			
			\subsection{Y-richting meten}
				Voor deze requirement moet het prototype in de Y-richting de afgelegde afstand kunnen bepalen doormiddel van een encoder. Deze test is voldaan wanneer de afstand dat de machine heeft afgelegd wordt bepaald door een encoder. Voor deze test moet de machine G-Code kunnen uitvoeren. 

				\paragraph{Deze} test kan alleen op de machine uitgevoerd worden. Hiervoor zijn de volgende dingen nodig:
				\begin{enumerate}
					\item Microcontroller met code dat G-Code kan ontvangen en uitvoeren en de afstand kan bepalen met een encoder.
					\item Encoder.
					\item Bedrading.
				\end{enumerate}

				\begin{enumerate}
					\item Bedraad de encoder met de microcontroller zoals aangegeven is in het elektrische schema.
					\item Verbind de microcontroller met een laptop met seriële monitor.
					\item Start de seriële monitor en stuur het commando $\$?$ om de huidige informatie op te halen.
					\item Beweeg de as met de hand en stuur het commando $\$?$ om de huidige informatie op te halen.
					\item Kijk of de het eerste getal veranderd is.
				\end{enumerate}

				\paragraph{Waarnemingen en conclusie}
					Na het sturen van $\$?$ geeft de machine overal 0 aan. Na het bewegen geeft de machine 17.2 aan dan 0 op de 1e plaats. Deze test is dus voltooid.

			\subsection{Z-richting meten}
				Voor deze requirement moet het prototype in de Z-richting de afgelegde afstand kunnen bepalen doormiddel van een encoder. Deze test is voldaan wanneer de afstand dat de machine heeft afgelegd wordt bepaald door een encoder. Voor deze test moet de machine G-Code kunnen uitvoeren. 

				\paragraph{Deze} test kan alleen op de machine uitgevoerd worden. Hiervoor zijn de volgende dingen nodig:
				\begin{enumerate}
					\item Microcontroller met code dat G-Code kan ontvangen en uitvoeren en de afstand kan bepalen met een encoder.
					\item Encoder.
					\item Bedrading.
				\end{enumerate}

				\begin{enumerate}
					\item Bedraad de encoder met de microcontroller zoals aangegeven is in het elektrische schema.
					\item Verbind de microcontroller met een laptop met seriële monitor.
					\item Start de seriële monitor en stuur het commando $\$?$ om de huidige informatie op te halen.
					\item Beweeg de as met de hand en stuur het commando $\$?$ om de huidige informatie op te halen.
					\item Kijk of de het eerste getal veranderd is.
				\end{enumerate}

				\paragraph{Waarnemingen en conclusie}
					Er is geen encoder te bevestigen op deze as. Deze test is dus niet voltooid. 


			\subsection{Modulair}
				Voor deze requirement moet de code modulair zijn. Deze test is voldaan wanneer er gemakkelijk een as toegevoegd kan worden. 

				\paragraph{Deze} test kan alleen op de machine uitgevoerd worden. Hiervoor zijn de volgende dingen nodig:
				\begin{enumerate}
					\item Microcontroller.
					\item Stappenmotoren(3) met drivers(3).
					\item Encoder.
					\item Bedrading.
				\end{enumerate}

				\begin{enumerate}
					\item Volg de handleiding om de code aan te passen zodat de X en Z as stappen tellen en de Y werkt met de input van de encoder.
					\item Verbind de microcontroller met een laptop met seriële monitor.
					\item Start de seriële monitor en stuur het commando G1 X10 Y10 Z10.
					\item Wacht totdat de machine 'OK.' geeft en de machine gaat bewegen.
				\end{enumerate}

				\paragraph{Waarnemingen en conclusie}
					Alle drie de motoren gaan bewegen en wanneer de locatie opgevraagd wordt met $\$?$ geeft het systeem hetvolgende aan: (0.0, 10.0, 0.0; 0.0, 10.0, 0.0; 0.0, 0.0, 0.0). Dit betekend dat de test geslaagd is. 




			\subsection{Conclusie}
				Na testen is de conclusie dat de freesbank in alle richtingen bewogen kan worden, G-Code kan uitvoeren, modulair is en de locatie kan bepalen op de Y-as.
				\begin{center}
					\begin{tabular}{|c|c|c|}
						\hline
						Soort & Requirement & Uitslag \\
						\hline
						Funct & De freesbank moet G-Code kunnen ontvangen en uitvoeren. & Behaald. \\
						\hline
						Funct & De freeskop moet in de X-richting kunnen bewegen. & Behaald \\
						\hline
						Funct & De freeskop moet in de Y-richting kunnen bewegen. & Behaald \\
						\hline
						Funct & De freeskop moet in de Z-richting kunnen bewegen. & Behaald \\
						\hline
						Funct & De positie van de freeskop op de X-as  & Niet behaald \\
						&moet bepaald worden met een encoder. & \\
						\hline
						Funct & De positie van de freeskop op de Y-as & Behaald \\
						&moet bepaald worden met een encoder. & \\
						\hline
						Funct & De positie van de freeskop op de Z-as & Niet behaald \\
						&moet bepaald worden met een encoder. & \\
						\hline
						Niet. Funct & De software moet modulair opgebouwd zijn. & behaald \\
						\hline
					\end{tabular}
				\end{center}

	\newpage
	\Large
	\textbf{Changelog}
	\begin{center}
		\begin{tabular}{|c|c|}
			\hline
			Datum & verandering \\ 
			\hline
			1-12-2025 & Begonnen met stage verslag maken van losse documenten \\
			\hline
			10-12-2025 & Feedback verwerkt van studenten \\    
			\hline
			05-01-2026 & Document gereorganiseerd en analyse verbeterd \\
			\hline
			06-01-2026 & Stakeholders verplaatst, spelling, onderzoek verplaatst/herschreven \\
			\hline
			08-01-2026 & bijlage toegevoegd. \\
			\hline
			14-01-2026 & ontwerpen toegevoegd en aan realisatie gewerkt\\
			\hline
			27-01-2026 & Realisatie ingevuld, testrapport toegevoegd. Spellingcheck \\
			\hline
			29-01-2026 & revision \\
			\hline
			30-01-2026 & revision \\
			\hline
		\end{tabular}
	\end{center}
\end{document}